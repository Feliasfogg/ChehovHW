1. История и развитие языка С++. Актуальные стандарты языка С++
В 83 году Страутструп работавший в Bell labs расширил и дпоплнил Си, назваз его Си с классами, так родился С++
Выпускает комитет стандартизации с++, сейчас актуальны с++11 с++14 с++98 
-поддержка стабильности языка и обеспечение совместимости с C++98 и, по возможности, с Си;
-предпочитается введение новых возможностей через стандартную библиотеку, а не через ядро языка;
-предпочитаются изменения, которые улучшают технику программирования;
-совершенствовать C++ с точки зрения системного и библиотечного дизайна, вместо введения новых возможностей, полезных для отдельных приложений;
-увеличивать типобезопасность для обеспечения безопасной альтернативы для нынешних опасных подходов;
-увеличивать производительность и возможности работать напрямую с аппаратной частью; 

2. Основные принципы объектно-ориентрированного программирования
функции и данные объекта объединены между собой и представляют единую сущность.
-Инкапсуляция - сокрытие данных и/или методов внутри объекта, это защита программиста от самого себя, скрывать данные можно с разным уровнем доступа private или protected.
-Наследование - наследование от базового класса к дочернему классу методов и функций, так же дочерний класс может содержать свои собственные методы и функции.
-Полиморфизм - способность объекта реагировать разными методами в зависимости от того, что с этим объектом происходит. Например у базового класса есть виртуальные методы, при создании объекта
дочернего класса ОС создает таблицу виртуальных методов, и имея массив разнородных объектов(но относледованных от базового класса), каждый объект массива может по своему реагировать при вызове
одного и того же метода. Кстати можно и просто перегрузить методы, но тогда не получится сделать массив, именно для таких целей и используется virtual
-Класс - по сути чертеж для будущего объекта. Модель типа данных. Объект - это сущность этого типа данных
Поля класса - по сути перемннные базовых типов(либо друугие объекты) внутри класса. Методы класса - функции и процедуры как-то обрабатывающие данные полей. Свойства - по сути это методы
доступа к полям класса. Если поле private.То мы не можем его переписать анпрямую, но можем сделать метод который может переписать.
Выдержка из вики.
Роджер Кинг аргументированно настаивал, что его кот является объектно-ориентированным. Кроме прочих своих достоинств, кот демонстрирует характерное поведение, реагирует на сообщения, наделён унаследованными реакциями и управляет своим, вполне независимым, внутренним состоянием.

3. Понятие класса и объекта
Класс - абстрактный тип данных, чертеж для будущего объекта. Объект - вполне конкретная сущность внутри адресного пространства компа. По сути какой-то предмет обладающий какими-то свойствами, и как-то описываемый
своим классом
4. Синтаксис описания и определения класса и его методов
		class Animal {
public:
    virtual	void voice() const {
        cout << str;
    }
protected:
    Animal() {}
    ~Animal() {}
     string str;
};

class Cat: public Animal {
public:
    Cat(){
    str="meow";
    }
    ~Cat() {}
};

5. Константные методы.
	Методы не изменяющие состояния объекта 
	пример голоса у кота, константные методы гарантируют программмисту что при их вызове мы никак не изменим
	внутреннее состояние объекта

6. Инкапсуляция. Синтаксис и назначение.
		class Animal {
public:
    virtual void voice()=0;
protected:
    Animal() {}
    ~Animal() {}
     string str;
};

class Cat: public Animal {
public:
    Cat(){
    str="meow";
    }
    ~Cat() {}
    virtual void voice(){
    cout <<str;
    }
};
Применяется для сокрытия методов или данных полей внутри объекта, защита программиста от самого себя. 
В данном случае у нас класс Animal, но мы не можем созхдать объъект такого класса т.к конструктор инкапсулирован и доступен только классам
отнаследованнм от Animal. Если сделать класс Cat отнаследованный от Animal то мы сможем сделать кота, и просто животное нет

7. Конструктор и деструктор.
это методы создающие объект и соответсвенно его разрушающие. Если объект содержит указатель на динамически выделенный кусок памяти то в деструкторе надо
прописать delete для удаления этого куска. Деструкторы бывают виртуальными. Конструктор может быть как protected так и public деструктор всегда public
Бывают перегруженные конструкторы. В случае если деструктора нету компилятор создаст деструктор по умолчанию. В случае если есть хотя бы один перегруженный
конструктор, то конструктор по умолчанию создан не будет. Так же существуют конструкторы копирования по умолчанию но мы можем написать свой
8. Перегрузка операторов для пользовательских классов.
	void opertor+(const class &A){
		каким-то образом обрабатываем  сложение объектов, если это логически очевидно;
		Данный метод будет вызван для текущего объекта, и в него неявно передасться указатль this. Аргументом должен быть объект
		такого-же класса, ибо это логично.
	}

9. Конструктор копирования, перегрузка операции присваивания.
	
	class Animal {
public:
    Animal() {}
    ~Animal() {}
    Animal(const Animal& A) {}//как-то копируем
    Animal& operator=(const Animal& A){}//что-то куда-то присваиваем, возвращаем ссылку на наш собственный объект return *this;
};
Можно вызвать конструктор копирвоания при инициализхации одного объекта другим
Cat A; Cat B(A);
Если написать 
A=B; то будет вызван оператор = но если написать Cat A=B; будет вызван неявно конструктор копирвоания. Т.к инициализация идет во время создания объекта
В случае простого если мы не описали оператор =  он будет сгенерирован автоматически и по сути создает побитовую копию объекта
Оператор присваивания удобен тогда когда мы работаем с объектами имеющими указатели на куски динамически выделенной памяти. Хотя в прицнипе мы можем использовать
и конструктор копирования с динамическим выделением собственной памяти. Они выпаолняют одну целю переписывают данные из одного объекта в другой


10. Дружественные функции и перегрузка операторов для стандартных классов.
	объявляется как friend внутри класса с которым надо дружить.
	Могут быть так же дружественные классы. И те и другие имеют доступ к приватным полям класса.
	оператор + стандартного класса string Складывает строки
	оператор = Копирует одну строку в другую, одно дерево в другое дерево, один вектор в другой вектор

11. Дружественные классы.
Объекты класса который дружит имеет доступ к приватным полям объекта класса с которым дружат. объявляются так же friend classname;
12. Наследование.
Наследование одним классом свойств другого класса, полей методов
class Animal {
public:
    virtual void voice()=0;
protected:
    Animal() {}
    ~Animal() {}
     string str;
};

class Cat: public Animal {
public:
    Cat(){
    str="meow";
    }
    ~Cat() {}
    virtual void voice(){
    cout <<str;
    }
};
Класс кот имеет доступ к полям protected & public класса животное, доступ у кота public. Соотвтственно у кота есть все те же методы и поля
что и у животного, но мы можем перегрузить методы или добавить свои поля или методы
13. Полиморфизм.
Способность объекта по разному реагировать на вызовы. Если у нас есть массив разнородных животных но относледованных от одного базового класса, и у базового
класса есть виртуальный метод "голос" - мы можем заставить каждый элемент массива, т.е каждое животное в ответ на вызов "голос", образно говоря кричать по своему,
котики будут мяукать, собачки лаять, хотя они все засунуты в один массив из животных; 
14. Позднее связывание. Таблица виртуальных функций.
	связывание – это ассоциация некоторго синтаксического элемента, с логической частью программы.
	Например так называемая Диспетчеризация виртуальных методов является формой позднего связывания, т.к по сути у нас узвестно на этапе раннего свзяывания,
	что есть какие-то виртуальыне методы, но в определенном куске кода будет вызван один из этих виртуальных методов и какой именно мы узнаем на этапе выполнения
	самоей программы. Т.е мы логически свзяываем на этапе компиляции кусок кода определяющий наличие виртуальных методов, тем самым мы гарантируем что у нас 
	действительно будут виртуальные методы. Но когда программа скопилировалась и запускается только тогда мы связываем кусок кода овтечающий за вызов виртульного
	метода с конкретным виртуальным методом. Как я понял все что гарантирует нам существование на этпае компиляции - это ранее сзвяывание, все что будет определено
	в процессе выполнения - это позднее. В качестве примера два перегруженных одноименных виртуальных метода, принимающих разные типы данных.Если во время вызова такого метода мы передадим ему инт - отработает метод перегруженный интом, если дабл то другой. А то какой именно тип данных мы передадим определяется в ходе
	выполнения программы. Мы можем вообще попробовать скормить стринги например.И в прицнипе программа скопилируется, но во время вызова код не отработает

	Таблица - механизм позволяющий осуществлять такое вот позднее связывание. Таблица объекта одержит адреса 
	динамически(т.е во время выполнения программы) связанных методов.Таблица едина для всех объктов одного класса.
	Компилятор создает отдельную таблицу vtable для каждого класса. После создания объекта указатель на эту vtable, называемый виртуальный табличный
	 указатель или vpointer, добавляется как скрытый член данного объекта (а зачастую как первый член). 
	 Компилятор также генерирует «скрытый» код в конструкторе каждого класса для инициализации vpointer'ов его объектов адресами соответствующей vtable.
	 Далее путем смещения по таблице получаем адрес конкретного метода.

15. Чисто виртуальные функции.
При вызове виртуальной функции в отнаследованном класса, если она ранее не переопределена, будет вызвана эта же функция из базового класса.
Но в случае когда базов класс не должен вообще ее вызывать, но в то же время мы хотим гарантировать наличие этой функции в отнаследованнх классах,
то мы можем сделать функцию чисто вртиуальной.Соотвественно тело в базовом классе мы писать не будем. 
virtual void voice()=0; Все. Теперь мы должны обязательно определить в отнаследованном классе как реализована эта функция иначе будет ошибка
Пример с котом выше, соответственно само по себе животное может и должно подавать голос. Но какой именнно голос - определяется конкретным животным
16. Множественное наследование. Виртруальный базовый класс.
Виртулльный базовый класс – это класс, который может использоваться лишь в качестве базового класса для некоторого другого класса. Класс является абстрактным, если он содержит хотя бы одну чистую виртуальную функцию.
В примере с животным и котом мы не можем создать животное само по себе, т.к его конструктор доступен только членам отнследованных классов.
В то же время животное содержит виртуальный метод голос, предоставляющий интерфейс для конкретной реализации в отнаследованных классах
Множественное наследование наследование class Spiderman: public Human, public Spider {}; 
Спайдермен имеет доступ к методам человека, соответственно методам паука. В прицнипе можно у базовых классов сделать напрмиер метод "перемещение",
и сделать его виртуальным, а у самого спадерамена не задавать конкретного метода перемещения, но тогда непонятно к какому именно из методов какого класса будет обращаться наш спайдермен если захочет полететь на паутине.

17. Списки инициализаторов. 
	инициализаруют поля на этапе компиляции
	class classname{
	public:
	classname(int a_, int b_): a(a_), b(b_){}
	int a; int b;
	};
	Список инициализации, например, - единственный выход для инициализации не статических констант класса.
	Список инициализации определяется порядком декларации полей в классе. Именно в том порядке в каком идут поля сверху вниз, они
	и будут проинициализарованы.От самой последовательности инициализаторов в списке инициализации порядок инициализации не зависит

18. Шаблоны классов.
любой шаблон начинается со слова template. Ключевое слово typename говорит о том, что в шаблоне будет использоваться встроенный тип 
данных, такой как: int, double,float, char и т. д. А ключевое слово class сообщает компилятору, 
что в шаблоне функции в качестве параметра будут использоваться пользовательские классы.
template <class T, typename P>
class Name
{
public: 
T age;//объект класса Т
P last_name;// некий тип базовых данных P инт,дабл или чар
//тело шаблона класса
};

19. Вложенные объявления классов, пространства имён.
пространство имен задает область видимости для переменнных, констант, и типов.
Обычно мы используем стандартное пространство имен на протяжении кода прогарммы подключение(директива using) этого пространства выглядит так
using namespase std; Мы можем использовать объекты и типы данных принадлижащие этому пространству имен.
можно также объявить отдельынй член этого пространства using std::cout;
Пространство имен выглядит так namespase nm{}. Сделать объект cout можно и так std::cout этим самым мы задеем конкретную область видимости для испоьзования
из нее конкретного объекта. Если написать выше using namespase std то можно не писать std::cout, а сразу cout; Есть кглобальное пространство имен :: 
и безымянные namespase { f1(); } вызов ::f1();
Внутри одного класса можно объявить другой класс. В такос улчае объекты вложенного класса будут видны только объектам внешнего класса. Объект
вложенного класса не может существовать  без объекта внешнего класса.Имя вложенного класса известно только в области видимости внешнего класса.
У внешнего класса нету прав доступа к приватнрм полям вложенного. Для этого мы должны объявить внешний класс другом для вложенного.
Если вложенный класс объявлен в секции public внешенго класса то мы можем обращаться к вложенному классу в теле программы указав область видимости
external_class::internal_class *ptr_for_internal_class_obj;

20. Стандартная библиотека шаблонов. Контейнеры.
Контейнеры это структуры для хранения данных, упорядоченные определенным образом. Контейнеры в библиотеке STL можно разделить на категории: 
последовательные контейнеры, ассоциативные контейнеры и контейнеры-адаптеры.
Ассоциативные контейнеры позволяют вставлять объекты как-то их сортирую.Например дерево  map, или multimap.
Послдовательные контейнеры ложат данные в том порядке в котором их ложит юзер, например вектора.
Контейнер-адаптер — это разновидность последовательного или ассоциативного контейнера, 
который ограничивает интерфейс для простоты и ясности. Контейнеры-адаптеры не поддерживают итераторы.

21. Стандартная библиотека шаблонов. Итераторы.
Итераторы - это объекты контейнера, которые каким-то образом перемещаются по контейнеру. По сути обычне указатели это итераторы с произвольным
доступом. Итераторы бывают входные (input) - служат для чтения адресуемых данных поддерживают,
операции инкремента и сравнивания, присваивания, выходные (output) адресуют аобъекты в которые данные должны быть записаны поддерживают инкремент и присваивание
Однонаправленные обладают всеми свойствами входных и выходных и могут пермещаться отначала в конец последовательности
ДВунаправленные как и однонаправленные, но могут перемещаться еще и назад. Поддерживают декремент.
Итераторы произвольного доступа могут перемещаться по последовательности как угодно.По сути обычные указатели и являются такими итераторами.
У векторов есть свои итераторы, у деревьев свои map::iterator it= tree.begin(); vector::iterator it=array.begin();

22. Стандартная библиотека шаблонов. Алгоритмы.
Реализует определения многих алгоритмов для работы с разными контейнерами.
А такжее наиболе часто испольуемые шаблонные алгоритмы

23. Операции преобразования типов.
const_cast<type> obj; делает объект неконстантным либо отменяет volatile. сам по себе volatile говорит компилятору что мы не хотим оптимизировать какой-то кусок
кода, и что значение такой переменной может быть измененео неявно самой ОС, без испоьзования операторов присваивания. В книге был пример с системным временем. 
Так вот \, чтобы компил не подставил вместо переменной конкретный литерал во время компиляции мы указываем этот атрибут и компилятор не оптимизирует эту переменную
dynamic_cast проверяет законность операции приведения типов. Если тип привести нельзя возвращает ноль, иначе приводит один тип к другому. Например указатель
дочернего класса указывает на объект дочернего класса. Мы можем привести такой указатель к типа базового класса, но он все равно будет указывать на объект
дочернего. Мы так же можем привести указатель базового класса к указателю дочернего, но только в том случае если указатель бахзового указывает на объект дочернего.
static_cast выполняет неполиморфное приведение типов, к какому-то из базовых типов. По сути анологичен явному преобразованию типов (int)double.
reinterpret_cast переводит один тип в совершенно другой. Например, его можно использовать для перевода указателя в целый тип и наоборот. Оператор reinterpret_cast следует использовать для перевода типов указателей, которые несовместимы по своей природе
24. Статические поля и методы.
Это поля и методы находящиеся в статистической области памяти во время выполнения программы. Если использовать статический метод или переменную внутри класса, то все объекты этого класса будут иметь доступ именно к оригинальной версии переменной или метода. Статический метод и переменную можно вызвать независимо от 
наличия объекта класса. Но нужно указать область видимости. Статический метод может работать одинаково со всеми объектами класса. Переменные внутри метода не всегда
будут statis. Удаление объекта класса никаки не влияет на ститический метод или переменную.