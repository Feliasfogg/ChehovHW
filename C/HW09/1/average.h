#ifndef AVERAGE_H
#define AVERAGE_H
template <typename I, typename D> D  average(I  N, D array[])/*сюда передаются параметры: N - число ячеек, оно всегда интовое
и D-тип массива, он может быть как интовым, так и даблом, в связи с этим функция имеет итоговым именно тип массива
т.к если функция будет вещественного типа, то в нее все равно можно вписать интовое занчение количества ячеек*/
{

    D summ=0;
    D aver;
    for(int i=0; i<N; ++i)
    {
        summ=summ+array[i];/*а тут мы берем интовые значения из массива и сумируем их в дабл summ, далее мы уже работаем только с
        этим даблом. Потом мы делим этот дабл на интовое значение  N - следовательно выражение приводится к большему типу т.е к даблу
        и этот получившийся дабл мы записываем в дабл aver( а если бы записали дабл в инт авер - у нас бы все обрезалось)
        поэтому при делелении казалось бы интовых значений в массиве получается занчение с плавающей точкой
        Схожая ситуация и с дабловым массивом. Т.к в итоге если даже мы туда записали только интовые значения при суммировании сумма
        попадет в тип дабл и и далее все будет работать так, как описано выше. А вот если бы мы взяли массив интовый, и ввели туда дабловые
        значение, то нифига бы не работало потому что дабловые значения при вводе обрезались бы.
        */
    }
    aver=summ/N;
    return aver;
}

#endif // AVERAGE_H
