#include "header.h"
void binarySearch(int array[], int size, int needle)
{
    /* в функцию мы передали уже отсортированный массив, это важно, т.к на основании того, что массив отсортирован, мы
    будем выдвигать следующие условия*/
    int i=0, j=size-1 , m, a=1;//a= управляющая переменная
    int elements=0, l,r;//сюда мы пишем количество найденных искомых цифр
    if(array[i]>needle||array[j]<needle)
    {
        cout<<"\tЭлемент отсутсвует в массиве\n";//если значение искомого жл-та выходит за гриницы массива
        a=0;
    }
    if(array[i]==needle)
    {
        cout<<"\tЭлемент найден в позиции "<< i<<endl;//если искомый элемент в самом начале массива
        a=0;
    }
    if(array[j]==needle)
    {
        cout<<"\tЭлемент найден в позиции \n"<<j<<endl;//если в самом конце
        a=0;
    }
    if(a)
    {
        while((j-i)>1)
            /* j-i>1 т.к если j-i=1 это означает, что в итоге мы будем проверять на наличие искомого числа постоянно одну и ту же ячейку массива равную i или j,
            и если в ней не окажеться искомого элемента, то мы попадем в замкнутый цикл, т.к условие j-i>0 будет постоянно верным*/
        {
            m=(j+i)/2;//делим массив пополам
            if(array[m]==needle)
            {
                ++elements;
                cout<<"\tЭлемент найден в позиции \n"<<m<<endl;//если искомое число попало ровно на середину массива
                /* т.к массив уже отсортирован по возрастанию, то попав на искомое число мы  точно знаем, что все такие же числа
                (имеется ввиду все тройки или все пятерки)
                 будут располагаться спарва и слева от того, позицию которого мы уже знаем, теперь нам нужно просто пойти вправо от найденной позиции
                 и соответственно влево, таким образом мы посчитаем общее количество одинаковых цифр*/
                l=m-1;//левая точка отсчета
                r=m+1;//правая
                while(array[l]==needle)
                {
                    ++elements;
                    --l;
                }
                while(array[r]==needle)
                {
                    ++elements;
                    ++r;
                }
                break;
            }
            if(array[m]>needle) j=m;//если искомое число меньше чем половина отрезка, то правой границе массива присваивается значение половины
            else i=m;//иначе - левой
        }
    }
    if(array[m]!=needle) cout<<"\tЭлемент не найден\n";
    cout<<"\tКоличество найденных элементов\n"<<elements<<endl;
}
